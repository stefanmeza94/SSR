NextJs:

Posto next radi na principu strukture foldera i tako odredjuje rute za nase stranice, svaki index.js fajl bice tretiran kao / nista, dakle ako se nalazimo u page folderu i napravimo index.js fajl on ce biti prikazan na adresi "localhost:3000". Ako pak imamo npr about folder unutar page foldera i tu stavimo index.js fajl on nece biti tretiran kao "localhost:3000/about/index.js/ vec samo /about. Drugi nacin za pravljenje ruta jeste da unutar istog foldera page napravimo fajl sa drugacijim imenom od index, npr portfolio.js. U tom slucaju ruta za taj fajl bice "localhost:3000/portfolio", dakle jedino index imenovane fajlove gleda posebno i njih uizma kao polaznu tacku u svakom folderu, medjutim ako imenujemo drugacije fajl onda ce njega gledati kao nesto sto treba da doda u url. 
Postoji opcija da se prave dinmacike rute. Njih pravimo tako sto pisemo [ ] oko imena fajla. Npr ovako: [id].js, izgleda cudno ali je ovo pravilna sintaksa, naravno ovaj id je proizvoljan mozemo da napisemo i projectid ne mora da bude id.
Da bi pristupili jedinstvenom itemu preko i prikazali jedan item iz neke kolekcije u toj dinamickoj ruti mozemo da koristimo hook iz next biblioteke tacnije iz next/router biblioteke "useRouter". Kada budemo pozvali usRouter hook (koji mozemo da koristimo u bilo kojoj funkconalnoj komponenti) on ce nam vratiti router objekat.

Public folder je takodje zanimljiv, next ce za nas sve fajlove iz public foldera da servira staticki to znaci da mozemo da referenciramo sta god zelimo u nasim js fajlovima, css-u iz tog public foldera (uglvanom se tu stavljaju slike, fontovi koje koristimo u projektu)
Tako da kada budemo zelili da referenciramo neku sliku iz public foldera mozemo da izostavimo public i samo pisemo "ime-slike.jpg"

Ako stavimo <a></a> unutar <Link> komponente, next ce da detektuje da smo stavili nas anchor tag i njega ce da renderuje (nece svoj, jer je <Link /> komponenta u pozadini zapravo <a></a>), uz funckonalnost <Link /> komponente, onda mozemo i da stilizujemo nas achnor tag. Ako vec stavljamo nas <a> onda ne stavljamo njemu href atribute gde zelimo da vodi taj link vec href atribute ostaje na <Link href='some-link' />, link komponenta ce automatiski da doda taj href nasem <a> tagu

React: 
Ako pogledamo obicnu react aplikaciju i udjemo u "view page source" videcemo da u body elementu nema bukvalno nikakavog sadrzaja. To je zato sto prilikom pocetnog odnosno incijalnog ucitavanja stranice ne dobijamo nista. Tek kasnije nas broswer renderuje sta smo prikazali unutar aplikacije. Kada se pokrene nas development server od strane reacta (npm start) na localhost:3000 to sto nama salje taj lokalni server jeste maltene prazan html sa nekim osnovim podacima. I tek nakon tog inicjalnog ucitavanja stranice nas browser renderuje sta treba u aplikaciji (u divu sa id-em "root"). Taj content koji nam serveria lokalni server jeste upravo to sto vidimo u view page source a tu ne postoje podaci koje vidimo renderovane na stranici kasnije, zato sto javascrtip odnosno react renderuje sta je potrebno nakon tog inicijalnog ucitavanja stranice (nakon dobijanja praznog html odnosno body taga). To naravno sa sobom povclaci par nedostatka. Nas user mora da ceka za podatke da budu ucitani da bi video nesto renderovano na ekranu. To resavamo sa nekim load spinerom dok se podaci ne ucitaju i stvari ne budu renderovane na ekranu. Jos veci problem moze da bude "Search Engine Optimization". Ako pravimo neki app gde google search engine mora da bude svestan naseg sadrzaja imacemo problem posto SEO upravo vidi taj pocetni prazan html. Naravno to nije uvek problem, ako imamo neki sajt gde user treba da se loguje da bi video neku stranicu ili ako pravimo neki admin dashboard unutar nase aplikacije onda search engine optimization mozda i nije bitan toliko jer user svakako nece da vidi nasu admin stranicu ali ako imamo neku aplikaciju koja sadrzi mnogo blogova koji su odmah dostpuni ili neka prodavnica gde user odma treba da vidi sve proizvode onda obicno zelimo da search engine optimization vidi taj nas sadrzaj na stranici. 
Kada povlacimo nesto sa servera, to se ne vidi prilikom pocetnog uctavanja stranice jer mi dobijamo prazan html i tek nakon tog pocetnog ucitavanja nas broswer ce da posalje zahtev i mi dobijamo nazad proizvode koje zelimo da prikazemo useru. To je nesto u cemu moze da nam pomogne next js.
NextJs nam pomaze sa necim sto se zove pre-rendering. Zamislimo da imamo neku stranicu, neku rutu koja ucitava neki fajl iz nasih ruta kojoj su potrebni podaci. Kada je zahtev poslat za ovu rutu ono sto nextJs radi jeste da ce on vratiti pre-renderovanu stranicu i to je razlika u odnosu na react. Kod react on nam pocetno vraca praznu html stranicu i ceo javascript kod i onda taj javascript kod pokrece i prikazuje nesto na stranici (sve se to desava extremno brzo tako da to nije problem) ali ako pogledamo primer gde bi trebali fetchujemo neke podatke koji treba da budu prikazani na nekoj stranici, takvi podaci se ucitavaju od servera i to ume da potraje, ali to naravno nije slucaj ako je stranica pre-renderovana kao kod nextJs-a. Umesto da ucitava te podatke tek nakon sto je server poslao te podatke klijentu, nextJs unapred renderuje stranicu i unapred renderuje sav html sadrzaj sa savim podacima koji su mozda potrebni, ucitava to unapred i unapred generise zavrsenu html stranicu tako da ova zavrsena i skroz kompletna html stranica bude poslata klijentu, odnosno useru. To je takodje dobro za SEO (Serach Engine Optimization). Naravno i dalje zelimo da imamo interaktivan react app, tako da nextJs ne salje samo pre-renderovanu stranicu vec ce da posalje i sav javascript kod koji mu pripada i odradice nesto sto se zove  hidratacija stranice, poslace javascript kod i taj kod ce da preuzme tu pre-renderovanu stranicu i pustice react da odradi ostatak posla.
Dakle nextjs za nas priprema unapred sav html sadrzaj i ucitava unapred te podatke koji ce eventualno da budu potrebni.
Ovaj pre-rendering utice samo na INICIJALNO UCITAVANJE, kada ucitamo nasu prvu stranicu ova stranica ce biti pre-renderovana (koju sada mogu da vide search engine crawleri) i zatim kad smo na web sajtu i kada se hidratise sa reactom dobijamo single page application, tj react preuzima odatle. Dakle kada bi od te pocetno ucitane stranice isli na neku sledecu stranica, ta sledeca stranica nije pre-renderovana vec nju renderuje react. 

Da bi uspeo u ovome nextJs ima dve forme pre-renderovanja. Mozemo da biramo koju cemo da koristimo. Prva forma i preporucena za koriscenje jeste "static generation". Druga forma, odnosno alternativa jeste "server-side rendering". Razlika je sto kod "static generation" sve stranice su ucitane unapred tokom build faze (kada bildujemo nasu aplikacju za production, dakle pre nego sto je deploy-ujemo pripremimo nase stranice), dok sa "server-side renderingom" sve stranice su kreirane bas na vreme nakon deploy-ovanja kada zahtev dodje do servera. Takodje postoji opcija i mesanje te dve forme. 

STATICKO GENERISANJE STRANICA:
Ideja iza statickog generisanja stranice je da se generise stranica unapred tokom build-a. Kada kazemo da se unapred generise mislimo da se sav html kod i svi podaci koji cine sadrzaj budu pripremljeni unapred. Dakle sve nase stranice su pripremljene tokom build faze pre nego sto deploy-ujemo aplikaciju. Posto su nase stranice pre-build tokom build faze jednom kada ih deploy-ujemo one mogu da budu kesirane od strane servera (od CDN koji mozda servira nasu aplikaciju) i onda predstojeci zahtevi sa klijentske strane mogu da budu servirani odmah sa tim pre-build stranicama. Naravno ostaje da se nasa aplikacija hidratise sa reactom, samo je razlika sto ta pocetna html stranica nije prazna kao kod obicnog reacta. 

Kako da kazemo nextJs-u da zelimo da nasa stranica bude pre-renderovana?
Postoji specificna funckija koju mozemo da exportujemo iz nase komponete, ali SAMO iz pages foldera, ne moze iz drugih react komponenti, vec samo iz komponenti koje se nalaze unutar pages foldera. Ta funkcija se zove export async function getStaticProps(). Posto je asinhrona vracace promise. Takodje specijalno za ovu funkciju jeste da mozemo da pokrecemo bilo koj kod koji bi se normalno pokretao na serveru. Znaci u toj funkciji ne pokrecemo kod koji se pokrece na klijentskoj strani, sto znaci da u toj funkciji necemo da imamo pristup nekim klijentskim api-ima, kao sto je window objekat npr, ali mozemo da kucamo kod koji bi se inace pokretao na serveru. Kod koji napisemo unutar funckije getStaticProps() nece da bude ukljucen u bundle koji je poslat klijentu, sav kod unutar te funkcije nece da bude vidljiv klijentu (ako imamo neki kod unutar te funkcije koji sadrzi neke kredencijale oni nece biti vidljivi klijentu). Kada exportujemo tu funkcije iz neke komponente koja se nalazi u pages folderu to ce signalizirati nextJs-u da ta komponenta treba da bude pre-generated. NextJs ce po defaultu da radi generise stranice unapred, ali postoje nacini da kazemo nextJs-u da ne zelimo da se neke stranice pre-generisu. 

NextJs ce prvo da pokrene ovu funckiju getStaticProps() i tu vracamo zapravo props koji ce da bude prosledjen nasoj komponenti HomePage, ali naravno to ce sve da se desi pre nego sto ova komponenta bude ucitana i servirana unutar browsera. Unutar ove funkcije uvek moramo da vracamo objekat koji ima props properti. Ova funkcija zapravo priprema props objekat za nasu komponentu. Kod unutar getStaticProps nikada nece da bude vidljiv na klijentskoj strani. Sada ako proverimo page source videcemo da se ovaj sadrzaj produkta vidi unutar html stranice koju smo ucitali u brosweru (za razliku od obicnog react-a koji prilikom prvog ucitavanja stranice salje prazan html body). Ovde u nextJs-u to fecovanje podataka se nije desilo na klijentskoj strani vec se to desilo na serveru.

NextJs ce podrazumevano da pre-renderuje sve komponente koje u sebi nemaju dinamcke podatke. 
U index.js fajlu koristimo fs module koji su sastavni deo noda. Medjutim njih mozemo da koristimo samo unutar getStaticProps() funkcije jer u toj funkciji mozemo da pisemo kod koji se inace pokrece na serveru, tj preko noda-a. Posto fs module i to pristupanje folderima ne mozemo da koristimo na klijentskoj react strani, nextJs ce za nas da podeli kod na pametan nacin, svi moduli koje smo importovali a koje koristimo samo unutar getStaticProps() funkcije NECE da budu bundle-ovani za frontend kod vec samo za server. Bas kao i getStaticProps() funkcija koja nece da bude bundle-ovana za klijentsku stranu, tj nece da bude poslata uz kod koji se salje brosweru. 

Ako imamo neki sadrzaj na stranici koji se cesto menja i update-uje, mi prilikom inicijalnog serviranja stranice moramo opet da izvrsimo build-vanje da bi se pokrenuo getStaticProps i da bi dobili te novije i updatevane podatke. Nextjs ima resenje za ovo. Prva opcija je da i dalje pre-buildujemo stranicu, i da nakon toga koristimo standardni useEffect hook unutar react komponente koja ce da fectuje updateovane podatke nakon renderovanja stranice, to znaci da ce useru uvek da bude prikazano bar nesto (ustajali podaci) i tek nakon renderovanja bice fechovani novi podaci. Postoji i alternativa za ovo koja je naravno bolja opcija. Kao sto znamo do sada ova getStaticProps funkcija se izvrsava nakon build-ovanja aplikacije (npm run build). To nije tacno do kraja. Zapravo mi mozemo da uticemo na to da to nije jedini put kada ce da se izvrsi getStaticProps funkcija. NextJs ima ugradjeni feature koji se zove "Incremental Static Generation", to znaci da ne generisemo stranicu staticki jednom prilikom buildovanja, vec se njeno izvrsavanje desava i kasnije nakon deploy-ovanja i tako updatujemo nase podatke u komponenti. Mozemo da odredimo i broj sekundi posle koje ce nasa komonenta da bude pre-generisana. Cim prodje broj sekundi koje smo odredili sa revalidate properti (koji vracamo na kraju getStaticProps) komponenta ce biti pre-generisana. 
Unutar getStaticProps() funkcije postoje i druge opcije (pored propsa) koje mozemo da vracamo u objektu na kraju. Na primer mozemo da vracamo properti revalidate: <za vrednost ide broj izrazen u sekundama>. Ovo revalidate znaci da ova stranica nece da bude pre-generisana sve dok ne istekne taj broj sekundi koji smo stavili. Moze da se desi da se nasi podaci cesto menjaju na stranici. To znaci da kada smo jednom build-ovali stranicu nextJs je pokrenuo getStaticProps i pre-renderovao sav sadrzaj na stranici, ali ako se nas sadrzaj promenio sada je potrebno opet da buildujemo nasu stranicu da bi se ucitali ti novi podaci i taj novi sadrzaj, odnosno da bi se pokrenuo getStaticProps. Resenje za takve situacije je upravo ovaj revalidte properti. On ce da se postara da za svaki sledeci zahtev na ovoj komponenti (ovoj stranici) trebala bi da bude re-generisana ukoliko je (npr) 10 sekundi proslo od kad je poslednji put re-generisana (10 sekundi je broj koji smo odredili revalidate propertiju). Ako je proso broj sekundi koje smo setovali i mi re-renderujemo stranicu on ce da pokrene opet getStaticProps i imacemo najsvezije podatke u komponenti. 

Unutar getStaticProps za sada imamo dva propertija koja vracamo na kraju funkcije u objektu, ali naravno da postoje jos properija koje mozemo da vratimo, jedan od njih je i notFound properti koji prima boolean vrednost. Ako podesimo notFound: true ova stranica ce vratiti not found stranicu odnosno 404 stranicu (koju za nas sam pravi nextJs). Mozemo da je koristimo kada hocemo da dobijemo neke podatke i ako se to ne izvrsi mozemo da prikazemo npr 404 stranicu. 

Takodje postoji properti po imenu redirect koji je zapravo objekat u kom odredjujemo destination properti i on prima vrednost stringa u kom pisemo rutu gde zelimo da posaljemo usera. Ako npr ne uspemo da fetchujemo podatke, mozemo da redirektujemo usera na neku stranicu. Vidi primer za obe u /page/index.js. Za sad nas objekat koji vracamo iz getStaticProps izgleda ovako {
  props: {
    products: data.products
  },
  revalidate: 10, <broj sekundi je naravno proizvoljan>
  notFound: true,
  redirect: {
    destinaton: '/no-data',
  }
}

getStaticProps(context) prima jedan argument po imenu context, on ce da predstavlja objekat. U tom objektu ce da se nalaze vise informacija o ovoj stranici kada je izvrsi nextJs. Npr iz tog context objekta mozemo da procitamo dinamicki url koji je trenutno ucitan u browseru. Iz njega mozemo da izvadimo params properti koji je pun sa key value parovima gde su kljucevi indentifikatori za dinamkiki url u nasem slucaju pid (dinamicki parametar unutar pages foldera)

Rekli smo da nextJs po defaultu pre-generise sve stranice, medjutim to nije slucaj sa dinamickim stranicama [id].js . Zasto je to tako, pa tehnicki ako pogledamo mi tu necemo da imamo samo jednu stranicu vec vise stranica za razlicite id-jeve, tehnicki to ce biti razlicite stranice mada sa istim layoutom, samo razlicitim sadrzajem, za razlicite id-jeve. Mozemo da imamo stranicu sa id1 sa id2 sa id100, tako da nextJs ne moze unapred da zna koju cemo mi tacno stranicu tu da renderujemo (za koj id) i zato dinamicke stranice nisu pre-generated. Naravno ono sto mozemo da uradimo jeste da kazemo nextJs-u koji ce sve id-jevi da budu dostpuni, tako da on zna za koje id-jeve treba da pripremi unapred stranice. To radimo sa funkcijom getStaticPaths() koja je takodje asinhrona. Nju takodje mozemo da koristimo samo unutar komponenti koje se nalaze u PAGES folderu, naravno moramo uvek da je exportujemo da bi nextJs bio svestan da smo je napisali. Ova funkcija getStaticPaths ce da sluzi da pokaze nextJs-u koje sve instance dinamickih stranica postoje i tako ce on da zna za koje stranice sve treba da unapred pripremi html, odnosno da ih pre-renderuje, tj da pozove getStaticProps. Iz ove funkcije takodje moramo da vratimo objekat. Moramo da vratimo paths properti koji ce da bude array sa objektima. Ti objekti moraju da sadrze params properti koji ce takodje da bude objekat u kom ce da budu key value parovi. Kljucevi ce da budu sve razlicite dinamicke stranice. A values ce da budu konkretne vrednosti za koje stranice treba da budu generisane. U tom objektu koji vracamo na kraju getStaticPaths moramo da dodamo jos jedan properti a to je fallback properti koji prima boolean vrednosti. Koja je fora sa fallback propertijem? 
Moze da se desi da mi na nasem sajtu imamo desetine hiljada stranica, pre-generisanje svih tih stranica moze da potraje. Naravno ako vodimo recimo blog postojace blogovi koje se cesto citaju dok neki blogovi vrv nece biti otvarani nikad. U tome moze da nam pomogne fallback properti. Dakle ako kazemo fallback: true, mi unutar paths propertija mozemo da odredimo samo one stranice za koje znamo da ce da budu dosta posecene, da one budu pre-generisane (unapred pripremljene) dok ove ostale koje nismo odredili u paths bice servirane u trenutku kada user klikne i taj zahtev dodje do servera. Ovo nam pomaze da odvojimo stranice za koje znamo da ce da budu dosta posecene a one manje posecene da budu generisane tek kada user klikne na njih, odnosno da ne budu pre-generated kao one stranice koje smo odredili u paths propertiju. Medjutim tu se javlja problem. Ako probamo manuelno da unesemo taj dinamicki url i da odemo na tu dinamicku stranicu, pre-generisanje stranice mozda nije zavrseno tako da ce nextJs da izbaci gresku gde ce reci da ne moze da procita podatke od undefined jer ako manuelno iskucamo url to pravi novi get request ka serveru i s toga moramo da imamo neki fallback unutar nase komponente koja renderuje te dinmacike stranice gde cemo npr da kazemo !podaci => <p>Loading...</p>. Jednom kada nasi podaci budu spremni za prikazivanje, nextJs ce sam da updateuje komponentu i mi dobijamo te zeljene podatke.
Postoji mogucnost da stavimo string "blocking" za vrednost fallback propertija, onda nam ne treba fallback unutar komonente kao npr loading jer ce nextJs sam da saceka da stranica bude pre-generated na serveru pre nego sto je servira klijentu, tako da necemo da dobijamo undefined unutar komponente.
Vrednost false fallback propertiju stavljamo kada smo manuelno odredili sve stranice da bugu pre-generated.

Ako fallback prebacimo na true, a unutar paths ucitamo sve idjeve dinamincki iz fetcovanog izvora, zelimo da sve dinamicke stranice bugu pre-generisane, ali ako se iskuca slucajno nesto u url-u sto ne postoji u tim fecovanim podacima, dobicemo gresku, zato moramo da proverimo u getStaticProps da li postoji product koji zelimo da prikazemo na toj dinamickoj stranici, ako ne postoji iz getStaticProps vracamo {notFound: true} odnosno izbacice nextovu 404 stranicu.


SERVERSKO GENERISANJE STRANICA:
Druga forma pre-renderinga stranica jeste 'server-side rendering'. Dok smo koristili getStaticProps i getStaticPaths mi zapravo nismo imali pristup tom request objektu koji nadolazi, zato sto ove dve funkcije nisu pozivane na samom requestu koji se pravi. Pozivane su kada buildujemo nas projekat, tj tokom build faze nextJs pripremi unapred nase stranice. Dakle unutar getStaticProps nemamo pristup tom nadolazecem zahtevu (objektu). Medjutim ova metoda nije dovoljna tako da moramo da koristimo pravi SSR (server-side rendering), tj da pre-renderujemo stranicu na svaki request koji dolazi do servera. Takodje ce nam trebati konkretan request objekat koji gadja server. NextJs nam daje funkciju koju mozemo da dodamo unutar komponenti koje se nalaze u pages folderu koja se izvrsava kad god se upucuje zahtev serveru iz te komponente. Tako da ta komponenta nece biti pre-renderovana unapred tokom build faze ili svakih par sekundi (incremental static generation) vec je funkcija koja se izvrsava na serveru nakon sto smo deployovali aplikaciju i koja se izvrsava svaki put kada dodje novi zahtev do servera. To se sve odvija preko funkcije getServerSideProps(). Ta funkcija ce takodje biti asinhrona i moramo da je exportujemo. Naravno mozemo da je koristimo samo unutar pages foldera. Jos jednom, nextJs ce da izvrsi ovu funkciju kad god se desi neki zahtev (request) unutar komponente. U toj funkciji moramo da vratimo objekat, u kom ce da imamo property props koji ce takodje da bude objekat. Bas kao i kod getStatisProps funkcije mozemo da koristimo propertije notFound, redirect, jedino sto nije isto kao kod getStaticProps funkcije jeste sto unutar getServerSideProps nemamo pristup revalidate propertiju. Taj properti ne mozemo da setujemo ovde zato sto se vec po defaultu getServerSideProps pokrece prilikom svakog zahteva na server i zato nema potrebe da se revalidate svake sekunde, zato sto ce se uvek pokretati kad dolazi novi zahtev. Taj props koji vracamo iz getServerSideProps bice prosledjen komponenti, s tim sto nece biti pozvan unapred kada buildujemo projekat, vec prilikom upucivanja svakog zahteva serveru.
Context properti koji dobijamo unutar getServerSideProps nije isti kao context kod getStaticProps funkcije. U contextu getServerSideProps funkcije dobijamo upravo taj zahtev (request objekat) koji dolazi sa klijentske strane, ali imamo pristup i response objektu koji cemo mi da posaljemo nazad klujentu (jako slicno node/epxress biblioteci). Kog getStaticProps i kod njegovog contexta to nije slucaj i ovde ne dobijamo request i response objekte jer se oni ne izvrsavaju na svaki zahtev klijenta vec se pre-generisu tokom buildovanja aplikacije.
Da se vratimo na getServerSideProps i njegov context, dakle rekli smo da u tom contextu dobijamo request i response objekte koje mozemo da distraktujemo iz contexta. Mi ne moramo da brinemo za slanje response objekta nazad klijentu to ce za nas da radi nextJs ali mozemo da modifikujemo pre nego sto ga nextJs posalje nazad. Isto tako mozemo da procitamo podatke iz request objekta koji dolazi do servera (npr da procitamo header koji je zakacen na taj request). 

Dok smo koristili getStaticProps i staticko generisanje stranica, za dinmicke stranice [].js morali smo da koristimo getStaticPaths da bi rekli nextJs koje sve instance dinamickih stranica postoje i koje zelimo da se pre-generisu. Medjutim sada kada koristimo getServerSideProps to nije slucaj. Ako imamo dinamicku stranicu [uid].js za razlicitog usera nama vise ne treba getStaticPaths niti bi mogli da ga koristimo. Sve sto nam treba jeste sama getServerSideProps funkcija 